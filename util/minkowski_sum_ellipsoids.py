import numpy as np
from shapely.geometry import Polygon
from shapely.ops import unary_union
from matplotlib import pyplot as plt
from matplotlib.patches import Polygon as MplPolygon
from util.minkowski_sum_polygons import minkowski_sum_polygons


def convert_ellipse_to_polygon(A_matrix, num_points=100):
    """
    Convert an ellipse defined by the matrix A to a polygon. Ellipse is defined A x with ∥x∥=1
    :param A_matrix: matrix of size (n, m)
    :return: polygon
    """
    # Create a vector in the unit circle
    # TODO: create unit balls of arbitrary dimension
    if A_matrix.shape[0] == 2:
        theta = np.linspace(0, 2 * np.pi, num_points)
        x = np.cos(theta)
        y = np.sin(theta)
        points_all = np.vstack((x, y)).T
        points_all = points_all @ A_matrix
    elif A_matrix.shape[0] == 4:
        theta = np.linspace(0, 2 * np.pi, num_points)
        alpha = np.linspace(0, np.pi, num_points)
        beta = np.linspace(0, np.pi, num_points)
        x = np.cos(alpha)
        y = np.sin(alpha) * np.cos(beta)
        p = np.sin(alpha) * np.sin(beta) * np.cos(theta)
        q = np.sin(alpha) * np.sin(beta) * np.sin(theta)
        points_all = np.vstack((x, y, p, q)).T
        points_all = points_all @ A_matrix

    return Polygon(points_all)


from shapely.geometry import Polygon
from shapely.ops import unary_union
import numpy as np


def resample_ellipse_points(ellipse_points, num_points):
    # Create a polygon from ellipse points
    P = Polygon(ellipse_points)

    # Resample points on the boundary
    vertices = np.array(P.exterior.coords)
    indices = np.round(np.linspace(0, len(vertices) - 1, num_points)).astype(int)
    resampled_vertices = vertices[indices]

    # Create a new polygon from resampled vertices
    P = Polygon(resampled_vertices)
    return P, resampled_vertices


def minkowski_sum_ellipsoids(A_matrices, num_points=100, resample_points=100):
    """
    This function has been generated by chatGPT.
    :param A_matrices: tensor of size (N, n, m)
    :return:
    """

    # create a vector in the unit circle
    N = A_matrices.shape[0]
    n = A_matrices.shape[1]
    m = A_matrices.shape[2]

    #for each A_matrix, add a small epsilon identity matrix to make it non-degenerate
    for i in range(N):
        A_matrices[i, :, :] += 1e-6 * np.ones((n, m)) #np.eye(n)
    #todo does not work for non-square matrices

    tot_polygon = convert_ellipse_to_polygon(A_matrices[0, :, :].T, num_points=num_points)
    for k in range(N - 1):
        current_polygon = convert_ellipse_to_polygon(A_matrices[k + 1, :, :].T, num_points=num_points)
        tot_polygon = minkowski_sum_polygons(tot_polygon, current_polygon)
        #check if tot_polygon has no attribute 'exterior'

        # resample the points
        tot_polygon, points_ellipsoids = resample_ellipse_points(np.array(tot_polygon.exterior.coords), num_points=resample_points)

    return tot_polygon, points_ellipsoids


# Example usage:
if __name__ == "__main__":
    # Example A_matrices input
    A_matrices = np.array([
        [[1, 0], [0, 1]], [[0.5, 0], [0, 1]]])
    polygon = minkowski_sum_ellipsoids(A_matrices)
    points = np.array([list(coord) for coord in polygon.exterior.coords])

    fig, ax = plt.subplots()

    polygon = MplPolygon(points, closed=True, facecolor='blue', alpha=0.5, edgecolor='black')
    ax.add_patch(polygon)

    ax.set_xlim(points.T[0, :].min() - 1, points.T[0, :].max() + 1)
    ax.set_ylim(points.T[1, :].min() - 1, points.T[1, :].max() + 1)
    ax.set_aspect('equal')
    plt.title("Minkowski Sum of Ellipsoids")
    plt.grid(True)
    plt.show()

    # # Plot the resulting Minkowski sum
    # plt.figure()
    # plt.plot(points[0, :], points[1, :], '-o', label="Minkowski Sum")
    # plt.axis('equal')
